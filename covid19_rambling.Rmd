---
title: "Looking at covid-19"
output: html_notebook
---

First we have to fetch the data. The source used here is https://covidtracking.com. The provide an API for fetching data by state. In the following data chunk, we end up with a list of lists. The number of measurements is shown along with the structure of a measurement.

```{r}
library(httr)
req <- GET("https://covidtracking.com/api/v1/states/daily.json")

data <- content(req, as = "parsed")
length(data)
str(data[[1]])
```

```{r, warning=FALSE}
library(httr)
library(data.table)
info_req <- GET("https://covidtracking.com/api/v1/states/info.json")
info <- content(info_req, as = "parsed")
length(info)
str(info[[1]])
state_info <- rbindlist(as.list(info), fill=TRUE)


get_state_name <- function(abbr) {
  state_info[state_info$state == abbr]$name
}

```


```{r}
library(data.table)
library(ggplot2)
dt <- rbindlist(data, fill=TRUE)
dt$date <- as.Date(as.character(dt$date), format = "%Y%m%d")
dt$dateChecked <- as.POSIXct(dt$dateChecked, "%Y-%m-%dT%H:%M:%S", tz="UTC")
dt$state <- as.factor(dt$state)
dt$fips <- as.factor(dt$fips)
dt <- dt[, -"hash"]

str(dt[1,])

picked <- dt[, c("state", "positive", "negative", "recovered","death", "total")]
pairs(picked)
```

```{r}
normalized <- cbind.data.frame(dt$positive/dt$totalTestResults, dt$negative/dt$totalTestResults, dt$recovered/dt$total, dt$death/dt$total)
colnames(normalized) <- c("pos", "neg", "recovered", "dead")

pairs(normalized)

```
  

```{r}
library(ggplot2)
library(cowplot)

plot_list <- list()

for(s in levels(dt$state)) {

  by_state <- dt[dt$state == s,]
  date_order <- order(by_state$date)
  
  by_state_ordered_by_date <- by_state[date_order,]
  # to find the earliest meausrement, restrict by complete cases
  # the date of element 0.
  earliest_death_report <- na.omit(by_state_ordered_by_date[,c("date","death")])[1,]
  earliest_death <- by_state_ordered_by_date[by_state_ordered_by_date$death > 0,c("date","death")][1,]
print(data.frame(state = s, earliest_report = earliest_death_report$date, earliest_death = earliest_death$date, earliest_number =earliest_death$death ))

  setnafill(by_state_ordered_by_date,type="locf", cols=c("death"))
  setnafill(by_state_ordered_by_date,type="const", fill=0, cols=c("death"))
 
  integral_breaks <- function(values) {
    breaks <- unique(floor(pretty(seq(0, 1.1 *  max(values) + 1))))
    return(breaks)
  }
  y_breaks <- integral_breaks(
    by_state_ordered_by_date$death
  )
  
  p <- ggplot(by_state_ordered_by_date, aes(x=date, y=death)) +
            geom_point(shape=1) +
            scale_y_continuous(breaks = y_breaks)

            # ggtitle(get_state_name(s))

  plot_list[[s]] <- p

}

step = 4
for (i in seq(from = 1, to = length(plot_list), by = step)) {

  group <- plot_list[i:(i+step-1)]
  #print(str(group))
  print(plot_grid(plotlist = group, ncol = 2,labels = names(group)))
}

 

```

Now let's look at overall population stats
```{r}
pop <- GET("https://api.census.gov/data/2019/pep/population?get=DATE_CODE,POP,NAME&for=STATE:*")
popdata <- content(pop, as = "parsed")

dt2 <- rbindlist(popdata[2:length(popdata)])
colnames(dt2) <- unlist(popdata[[1]])

dt2 <- dt2[dt2$DATE_CODE == 12,-c("DATE_CODE")] 

dt2$POP <- as.numeric(dt2$POP)
dt2$state <- as.factor(dt2$state)
names(dt2)[names(dt2) == "state"] <- "fips"
dt2[order(dt2$NAME),]

ggplot(dt2, aes(x=NAME,y=POP), fill=NAME) + geom_bar(stat="identity")

dt3 <- merge(dt,dt2, by="fips")

```

Now we can calculate deaths per million of population.

```{r}

dt3[["dpm"]] <- dt3$death / dt3$POP * 1e6
dt3

```

Now lets, foe each fips code, find the earliest day where dpm is >= 1 and then what is the dpm 21 days after that point.

```{r}

for (code in levels(dt3$fips)) {
  selected <- dt3[dt3$fips == code,]
  for (index in seq(along=selected$dpm)) {
    index
     selected[index,]$dpm
     if ( selected[index,]$dpm >= 1 ) {
      print(selected[index,]$state)
      print(selected[index,]$date)
      break
    }  
  }
}
```


